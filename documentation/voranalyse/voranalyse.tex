\documentclass[10pt,paper=a4,final]{scrartcl}
\usepackage[utf8]{inputenc}
\usepackage{tabularx}	%used for the tables
\usepackage{geometry}	%allows us to specify the 'seitenrand'
\usepackage[table]{xcolor}	%allows us to make colored fields in the tables
\usepackage{graphicx}	%package used to include graphics
\usepackage{hyperref}   %used to make klickable links

%\hypersetup{linktocpage}       %make the tableofcontent klickable
\hypersetup{
  colorlinks,
  citecolor=black,
  filecolor=black,
  linkcolor=black,
  urlcolor=black
}

%These two lines will allow us to specify our own headers/footers
\usepackage{fancyhdr}
\pagestyle{fancy}

%The next three lines set the default font to Arial
%use 'getnonfreefonts arial-urw' to install uarial on Linux systems
\usepackage[T1]{fontenc}
\usepackage[scaled]{uarial}
\renewcommand*\familydefault{\sfdefault}

\geometry{a4paper, top=20mm, right=20mm, bottom=20mm, left=20mm}
\title{Test}
\author{Bash Vi, Shylux, Kaleb Tschabolt}
\date{\today}

%defining header and footer
\fancyhf{}	%delete default values
\setlength{\headwidth}{\textwidth}	%header and footer width equal the text width
\fancyhead[LE,LO]{\includegraphics[scale=0.6]{header.png}}
\fancyhead[RE,RO]{ProjectExplorer}
\fancyfoot[CE,CO]{Speicherdatum: \today{}}
\fancyfoot[RE,RO]{\thepage}

\begin{document}
\maketitle
\newpage
\begin{tabularx}{\textwidth}{ r X }	%X fields are stretched over the whole space
\textcolor{white}{{\bf Status}}\cellcolor{blue!80!} & {\bf In Arbeit}/In Pruefung/Abgeschlossen\cellcolor{blue!20!} \\
\textcolor{white}{{\bf Projektname}}\cellcolor{blue!80!} & Projektexplorer\cellcolor{blue!20!} \\
\textcolor{white}{{\bf Projektleiter}}\cellcolor{blue!80!} & Niklaus Hofer\cellcolor{blue!20!} \\
\textcolor{white}{{\bf Auftraggeber}}\cellcolor{blue!80!} & M. Frieden, GIBB\cellcolor{blue!20!} \\
\textcolor{white}{{\bf Autoren}}\cellcolor{blue!80!} & Niklaus Hofer\cellcolor{blue!20!} \\
\textcolor{white}{{\bf Verteiler}}\cellcolor{blue!80!} & Lukas Knoepfel, Kaleb Tschabolt, Niklaus Hofer\cellcolor{blue!20!}
\end{tabularx}
\newline
\newline
\newline
{\bf Aenderungskontrolle, Pruefung, Genehmigung}
\newline

\begin{tabularx}{\textwidth}{l l X X}
\textcolor{white}{Version}\cellcolor{blue!80!} & \textcolor{white}{Datum}\cellcolor{blue!80!} & \textcolor{white}{Beschreibung, Bemerkung}\cellcolor{blue!80!} & \textcolor{white}{Name oder Rolle}\cellcolor{blue!80!} \\
\cellcolor{blue!20!} & \cellcolor{blue!20!} & \cellcolor{blue!20!} & \cellcolor{blue!20!} \\
\cellcolor{blue!20!} & \cellcolor{blue!20!} & \cellcolor{blue!20!} & \cellcolor{blue!20!} \\
\cellcolor{blue!20!} & \cellcolor{blue!20!} & \cellcolor{blue!20!} & \cellcolor{blue!20!} \\
\cellcolor{blue!20!} & \cellcolor{blue!20!} & \cellcolor{blue!20!} & \cellcolor{blue!20!} \\
\end{tabularx}
\newline
\newline
\newline
{\bf Definitionen und Abkuerzungen}
\newline

\begin{tabularx}{\textwidth}{l X}
\textcolor{white}{Begriff/ Abkuerzung}\cellcolor{blue!80!} & \textcolor{white}{Bedeutung}\cellcolor{blue!80!} \\
\cellcolor{blue!20!} & \cellcolor{blue!20!} \\
\cellcolor{blue!20!} & \cellcolor{blue!20!} \\
\end{tabularx}
\newline
\newline
\newline
{\bf Referenzen}
\newline

\begin{tabularx}{\textwidth}{l X}
\textcolor{white}{Referenz}\cellcolor{blue!80!} & \textcolor{white}{Titel, Quelle}\cellcolor{blue!80!} \\
\cellcolor{blue!20!}[1] & \cellcolor{blue!20!} \\
\cellcolor{blue!20!}[2] & \cellcolor{blue!20!} \\
\cellcolor{blue!20!}[3] & \cellcolor{blue!20!} \\
\end{tabularx}
\newpage
\tableofcontents
\newpage

\section{Zweck des Dokuments}
In der Voranalyse geben wir einen groben Einblick in die kuenftigen Funkionen unseres Programmes. Hier werden die Ziele festgesetzt und Entscheidungen \"uber die zu verwendeten Technologien begruendet und festgehalten.
\section{Ist-Aufnahme und Ist-Analyse}
\subsection{Beschreibung des Ist-Zustands (Ist-Analyse)}
\begin{itemize}
  \item Da das Projekt neu gestartet wird, existiert keine Vorarbeit, auf der wir aufbauen könnten.
  \item Einige der Ideen können aber mit denjenigen von Gnome Zeitgeist [1] und Apple timemachine [2] verglichen werden.
  \item Als bestehende Lösung könnte man die herkömmliche, hierarchische Struktur von Dateisystemen ansehen. Allerdings wollen wir diese nicht ersetzen, sondern lediglich um weitere Möglichkeiten ergänzen.
\end{itemize}
\subsection{Schwachstellenanalyse}
\begin{itemize}
  \item Es existiert zwar kein Vorsystem, dessen Schwächen wir hier beschreiben könnten. Ich möchte hier aber auf die Schwächen herkömmlicher Dateiverwaltungssysteme eingehen.
  \item Diese haben vorallem das Problem, dass sich die Anwender herkömmlicher Dateisysteme eine Dateistruktur ausdenken und merken müssen. Sollten sie die Struktur jemals vergessen, so ist es schwierig Dateien zu finden. Auch ist das System recht unflexibel, wenn es darum geht Dateien, die zum gleiche Thema gehören, die aber weit über die hierarchische Struktur verteilt sind, zusammen zu verwalten.
\end{itemize}
\subsection{Sicherheit}
Es existieren keine Vorsysteme, die daher auch keine Sicherheitsl\"ucken aufweisen k\"onnen. \\
Erw\"ahnenswert scheint hier aber, einmal mehr, das cloud computing. Alle Daten bei einem storage Anbieter zu lagern l\"oest nicht nur das Problem der Backups, sondern erlaubt auch das blitzschnelle Durchsuchen der Dokumente, da viele der online Anbieter (insbesondere Google mit seinem online Office) die Dokumente indexieren und so das Durchsuchen mit komplexen Algorithmen erlauben. All diese Vorteile haben aber einen entscheidenden Nachteil: Die Kontroller \"uber die Dateien geht verloren. Der Storage-Anbiter hat, sofern man die Daten nicht manuell verschl\"usselt, vollen Zugriff darauf. Zudem besteht hier der Nachteil dass ein Angreiffer alle die Daten bequem einsehen wenn er an das Passwort kommt.
\subsection{Zuk\"unftige Entwicklung}
Das Gnome Zeitgeist Projekt [1] setzt einige innovative Ideen um, die das verwalten von Dateien komfortabler machen sollen.
Dabei geht es darum, dass dokumentiert wird wann welche Dateien geöffnet wurden und welche anderen zur selben Zeit geöffnet waren. Es ermöglicht dann nicht nur die chronologische Ansicht der Dateien, sondern auch Abfragen wie “welches war der Song, den ich während dem Betrachten jener Bilder gehört habe?”.
\begin{itemize}
  \item Welche Trends zeichnen sich ab und sind sie relevant?
    \begin{itemize}
      \item Ein Trend ist dahingehend fest zu stellen, dass immer mehr Volltextsuchen für den Desktop zu Einsatz kommen, zum Beispiel Google Desktop search [3].
    \end{itemize}
  \item Wie ist die Bereitschaft zu Veränderungen? 
    \begin{itemize}
      \item Die Bereitschaft grosse Änderunge ein zu gehen scheint nicht besonders gross zu sein.\\
	So wird das aktuelle System schon seit Jahrzehnten nahezu unverändert verwendet.\\
	Um die User nicht zu verwirren, vermeiden die Hersteller grundlegende Änderungen und verhalten sich eher zurückhaltend.\\
	Auch Gnome Zeitgeist wurde aus dem Gnome 3.0 Release gestrichen [4] und wird wohl vom Anwender selbst installiert werden müssen.
    \end{itemize}
  \item Welche Anforderungen muss das System in Zukunft erfüllen?
    \begin{itemize}
      \item Die User möchten Files mit anderen über die Ordner hinaus verknüpfen. Weg von der hierarchischen Struktur.
      \item Das System muss in der Lage sein auch sehr grosse Mengen an Dateien so zu verwalten, dass einzelne Dateien schnell und ohne Umwege gefunden werden können, ohne dass sich der User lange Dateipfade merken muss.
    \end{itemize}
  \item Wie wird sich das System entwickeln, wenn nichts geändert wird?
    \begin{itemize}
      \item Die Betriebsysteme werden eingebaute Funktionen zum tagen mitbringen. Diese Funktion gibt es bereits in Gnome Zeitgeist.
      \item Zum Versionieren gibt es heute schon einige einige Tools (meist Kostenpflichtig), die aber meist sehr undurchsichtig sind.
      \item Bequeme backup-timeline-Lösungen ähnlich Apple’s Zeitgeist werden wohl vermehrt eingesetzt werden, da sie das Erstellen und Verwalten von Backups vergleichsweise sehr einfach machen.
    \end{itemize}
  \item Wo wurden ähnliche Probleme schon gelöst?
    \begin{itemize}
      \item Windows 7 hat ein neues System zum erstellen ‘virtueller’ Ordner mitgebracht. Hier können Diese fassen mehrere Ordner und Dateien, unabhängig von deren Speicherort, in einem virtuellen Verzeichnis zusammen.
      \item Es gibt schon einige Taggingsysteme, auch auf Basis des Filesystems. 
      \item Abgesehen von Gnome Zeitgeist hat sich seit Jahren nur sehr wenige getan bei der Verwaltung von Dateien.
    \end{itemize}
  \item Welche Vorstellungen hat man von einer neuen Lösung?
    \begin{itemize}
      \item In dem Bereich gibt es einige interessante Experimente und Untersuchungen, ein allgemeiner Tenor über eine ‘Lösung der Zukunft’ ist aber nicht in Sicht.
      \item Evtl. wird sich das Problem auch von selbst lösen, falls die Verschiebung in die Cloud so von statten geht wie es sich einige Internetdienstleiste (Stichwort Google) vorstellen.
      \item Auch aufwendige Dokumentenverwaltungssysteme könnten in Zukunft öfters zum Einsatz kommen, besonders beim Einsatz in Firmen, die grosse Datenmengen sinnvoll verwalten müssen.
    \end{itemize}
  \item Was oder wer kann das zukünftige System beeinflussen?
    \begin{itemize}
      \item Das System könnte durch zwei Dinge stark beeinflusst werden. Eine Möglichkeit wäre, dass ein Startup, oder ein freies Projekt eine Lösung bringt, die derart genial ist, dass sie sich durchsetzt und dann auch in der Industrie (Windows, OS X) integriert wird.
      \item Die andere Möglichkeit wäre, dass der Branchenriese Microsoft eine Lösung in künftige Versionen von Windows integriert und so die Anwender auf ein neues System ‘zwingt’.
    \end{itemize}
  \item Welche kritischen Erfolgsfaktoren gibt es?
    \begin{itemize}
      \item Das System darf nicht kompliziert sein und die Nutzer verwirren. Viele Nutzer hatten bereits Probleme damit das aktuelle System zu erlernen. Falls ein neues nicht sofort verständlich ist, so werden sie es ablehnen.
    \end{itemize}
\end{itemize}
\newpage
\section{Systemziele}
\begin{tabular}{ |l|p{2.5cm}|l|l|l|p{4.0cm}| }
  \hline
  \bf Bezeichnung & \bf Beschreibung & \bf Priorit\"at (0-3) & \bf Zielhierarchie & \bf Zielkategorie & \bf Kriterien zur Bewertung \\ \hline
  Performance & L\"auft das program schnell? & 2 & & & Das Programm sollte ähnlich schnell reagieren, wie die von den verschiedenen Systemen mitgelieferten Dateimanager.
  Keinenfalls darf sich die Benutzung so träge anfühlen, dass man lieber auf die Vorteile des Systems verzichtet. \\ \hline
  Qualit\"at & Kann das Programm einfach erweitert werden? & 2 & & & Das Programm ist objektorientiert aufgebaut.
  Die Benennung von Objekten und Variablen ist einheitlich.
  Das Programm ist klar und verständlich dokumentiert. \\ \hline
  Sicherheit & Das Programm reist keine Sicherheitslücken in die Mechanismen der jeweiligen Betriebssysteme. & 3 & & & Firewalls und Rechteverwaltungssysteme werden nicht umgangen. \\ \hline
  Kompatibilit\"at & Läuft das Programm auf allen wichtigen Betriebssystemen. & 2 & & & Das Programm soll auf folgenden OS laufen: Windows, Linux, OS X \\ \hline
  Datenkonsistenz & Die Metadaten werden ohne ueberfluessige Redundanze & 1 & & & Die Metadaten Ablage verhindert vom Design her widersprüchliche oder doppelte Angaben. \\ \hline
\end{tabular}
\section{Fachlicher Soll-Zustand}
\subsection{Hauptaufgaben der neuen L\"osung}
\begin{itemize}
  \item Hauptaufgaben
    \begin{itemize}
      \item Dateien verwalten
      \item Dateien können mit Tags versehen werden.
      \item Dateien können nach Tags sortiert werden.
      \item Operationen können auf eine Auswahl an Dateien (z.B. alle Dateien eines bestimmten Tags) angewandt werden.
      \item Das Programm kann Dateien Versioniren.
    \end{itemize}
  \item Informationsflüsse
    \begin{itemize}
      \item Informationen zu den Dateien (Tags) werden dauerhaft abgelegt.
      \item Werden Dateien mit Hilfe anderer Programme verschoben/erstellt, sollte das Programm (zumindest falls es läuft, vorzugsweise aber immer) davon in Kenntnis gesetzt werden.
    \end{itemize}
  \item Schnittstellen nach aussen, zu externen Systemen
    \begin{itemize}
      \item Das Programm muss Zugriff auf ein System haben, in dem es die Tags ablegen kann.
      \item Zugriff auf das Dateisystem muss vorhanden sein, um das Verschieben von Dateien zu registrieren und um Dateien zu archivieren/versioniren.
      \item Falls das Programm ein CLI erhält, so kann es natürlich mit Scripts bedient und automatisiert werden.
    \end{itemize}
  \item Datenfluss
\end{itemize}
\subsection{\"Ubersicht \"uber die erforderlichen Informationen / Daten}
\begin{itemize}
  \item vom Dateisystem
    \begin{itemize}
      \item Name der Datei
      \item Wo liegt die Datein (Verzeichnis)
      \item Andere Metadaten wie Zugriffsrechte, Datum der letzten Ver\"anderung, \ldots
    \end{itemize}
  \item von der Metadaten-Ablage
    \begin{itemize}
      \item Welche Tags wurden der Datei X zugeordnet
    \end{itemize}
  \item Dateisystem-Events
    \begin{itemize}
      \item Datei(en) wird/werden gel\"oscht
      \item Datei(en) wird/werden verschoben
      \item Datei wird ver\"andert
    \end{itemize}
\end{itemize}
\subsection{Anforderungen bez\"uglich Informationssicherheit und Datenschutz}
\begin{itemize}
  \item Informationssicherheit:  Verfügbarkeit, Vertraulichkeit, Integrität
    \begin{itemize}
      \item Die Verfügbarkeit des Programms hängt lediglich von der des Dateisystems ab und kann mit dieser gleichgesetzt werden.
      \item Das Vertrauen des Users wird gewonnen, indem nichts nach aussen (internet) geschickt wird.
      \item Die Integrität der Daten zu garantieren ist von daher eine Herausforderung, als dass das Programm mitbekommen muss, wenn Dateien verschoben werden und das registrieren muss. Ansonsten verweisen Metadaten ins Leere und Dateien verlieren die Ihnen zugeordneten 	Metadaten.\\
	Dieses Problem kann durch das Abhören von Dateisystem Events behoben werden.\\
	Umgehen liesse sich das Problem nur dann, wenn die Tags in den Filesystem-metadaten gespeichert würden.\\
    \end{itemize}
  \item Datenschutz
    \begin{itemize}
      \item Da das Programm lokal auf dem Computer läuft und nicht in die Zugriffsmechanismen des vorhandenen Systems eingreift geht die einzige Gefahr davon aus, dass der Speicherort der Tags für andere User frei zugänglich ist.\\
	Um das zu verhindern müssen die Tags entweder direkt in der jeweiligen Datei abgelegt werden oder, falls eine Datenbank zum Einsatz kommt muss diese in einem Verzeichnis abgelegt werden, auf das nur der jeweilige Benutzer Zugriff hat.
    \end{itemize}
\end{itemize}
\newpage
\section{L\"osungsvarianten}
\subsection{Zu verwendende Programmiersprache}
\subsubsection{L\"osungsvariante 1: Java}
\paragraph{Beschreibung der L\"osungsvariante}
Bei dieser L\"osung w\"urde Java als Programmiersprache f\"ur das Projekt verwendet. Java hat den Vorteil, dass der Interpreter eine sehr grosse Verbreitung geniesst und alle beteiligten Entwickler mit der Sprache vertraut sind.
\paragraph{Struktur (Grobe Architektur)}
Java hat sehr viele Module, die nicht nur die Entwicklung erleichtern, sondern auf den Zugriff auf verschiedene Formate, die zum Abspeichern der Daten verwendet werden k\"onnen (Siehe unten <LINK ZU KAPITEL>).
\paragraph{Externe und interne Schnittstellen}
Wie bereits erw\"ahnt bietet Java viele Schnittstellen zu g\"angigen Datenbanken und Dateiformaten an.\\
Zudem hat Java verschiedene Frameworks die zur Erstellung des GUIs verwendet werden k\"onnen und sich zum Teil stark an den nativen Look des jeweiligen Systems anpassen.\\
Java’s Ausgabe in die Konsole hingegen ist eher langsam.\\
\paragraph{Abdeckung der Anforderungen}
\begin{itemize}
  \item {\bf Performance:} Java gilt heute als recht schnell.
  \item {\bf Flexibilit\"at:} Java gilt zur Zeit als die meist verwendete Programmiersprache \"uberhaupt, was den Vorteil mit sich bringt, dass sehr viele Programmierer in der Lage sind damit geschriebene Programme weiter zu entwickeln oder an zu passen.
  \item {\bf Sicherheit:} Dadurch dass Java code in der JVM ausgef\"uhrt wird, wird das ohnehin geringe Sicherheitsrisiko, dass durch den Einsatz der Software entsteht, noch weiter verringert.
  \item {\bf kompatibilit\"at:} Java ist f\"ur nahezu alle computer (egal ob Desktop oder handheld) verf\"ugbar, in verschiedenen Varianten, die teils selbst den hohen Offentheitsanspr\"uchen des Debian Projektes gen\"ugen. Die Verwendung vieler verschiedener Interpreter bringt aber auch Probleme. So sehen etwa Programme die f\"ur Sun/Oracle Java entwickelt wurden im Betrieb unter IcedTea etwas anders aus.
\end{itemize}
\paragraph{Realisierbarkeitsbetrachtung}
Die beteiligten Programmierer haben alle bereits Erfahrungen mit Java. Zudem findet man im Internet schnell Hilfe zu fast allen Bereichen der Programmiersprache.\\
Die Realisierbarkeit ist also durchaus gesichert wenn Java zum Einsatz kommt.

\subsubsection{L\"osungsvariante 2: Python}
\paragraph{Beschreibung der L\"osungsvariante}
Zur Implementierung des Programmes w\"urde hier Python verwendet. Die moderne Programmiersprache kommt heute immer \"ofters zum Einsatz und l\"auft auf allen g\"angigen Betriebssystemen.
\paragraph{Struktur (Grobe Architektur)}
Auch Python bietet Schnitstellen zu fast allen wichtigen Formaten und Datenbanken. Zudem bietet Python aber noch den Vorteil, dass es auch sehr viele low-level-Schnittstellen gibt, die auch sehr hardware (oder, hier von gr\"osserem Interesse, Dateisystem)nahe Operationen erlauben.
\paragraph{Externe und interne Schnittstellen}
Python braucht ebenfalls einen Interpreter. Dieser ist aber f\"ur alle g\"angigen Betriebssysteme verf\"ugbar. Zudem kann Python code auch in der weit verbreiteten Java Virtual Machine ausgef\"uhrt werden [5].
\paragraph{Abdeckung der Anforderungen}
\begin{itemize}
  \item {\bf Performance} Python gilt als sehr performante Programmiersprache. Die Performance w\"urde f\"ur unseren Einsatzzweck vollauf gen\"ugen.
  \item {\bf Flexibilit\"at} Python hat ein ausgepr\"agtes Objekt Modell und ist gut Verst\"andlich. Zudem steigt die Zahl an Python Entwicklern seit einger Zeit sehr rasch. Auch eine in Python geschriebene Implementierung k\"onnte also sp\"ater gut von einem anderen Programmierer erweitert oder ge\"andert werden.
  \item {\bf Kompatibilit\"at} Der Python Interpreter hat eine deutlich weniger grosse Verbreitung als Java, ist aber auf Unix-artigen Systemen meist enthalten und kann unter Windows einfach installiert werden. Es l\"asst sich zudem spekulieren, dass Oracles aktueller Umgang mit Java und insbesondere mit der community der Verbreitung von Java starch schaden wird, wodurch dessen Verbreitung evtl. hinter die von Python zur\"uckfallen k\"onnte.
\end{itemize}
\paragraph{Realisierbarkeitsbetrachtung}
Der Einsatz von Python hat den Nachteil, dass die beteiligten Entwickler damit weniger vertraut sind als mit Java. Allerdings ist dadurch der Lerneffekt gr\"osser. Zudem bietet Python m\"achtige Module, die die Arbeit vereinfachen.\\
Python ist auch insbesondere f\"ur die Entwicklung von GUIs gut geignet. Unter Linux gibt es eine Vielzahl von Projekten, die lediglich ein Python GUI f\"ur Tools darstellen, die ansonsten nur f\"ur die Konsole verf\"ugbar sind.


\subsection{Zu verwendende Ablage f\"ur die Metadaten}

\end{document}
